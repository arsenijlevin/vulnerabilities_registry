import { getVulnerabilityById } from '@api/vulnerability/handlers';

import { DateTimeFormat, OptionDTO } from '@api/types';
import { Prisma } from '@prisma/client';
import { format, parse } from 'date-fns';
import { setDefaultOptions } from 'date-fns';

import { ru } from 'date-fns/locale';

export type Vulnerability = NonNullable<Prisma.PromiseReturnType<typeof getVulnerabilityById>>;

export type VulnerabilityTable = Omit<
  Vulnerability,
  'long_text_description' | 'discovery_date' | 'is_fixed' | 'vuln_hardware' | 'vuln_types'
> & {
  discovery_date: string;
  is_fixed: boolean;
  vuln_hardware: OptionDTO[];
  vuln_types: OptionDTO[];
  description: string | null;
};

setDefaultOptions({ locale: ru });

export class VulnerabilityDTO {
  private id: Vulnerability['id'] = -1;
  private name: Vulnerability['name'] = '';
  private discovery_date: Vulnerability['discovery_date'] = null;
  private is_fixed: Vulnerability['is_fixed'] = null;
  private long_text_description: Vulnerability['long_text_description'] = '';
  private vuln_hardware: Vulnerability['vuln_hardware'] = [];
  private vuln_types: Vulnerability['vuln_types'] = [];

  constructor(vulnerability?: Vulnerability) {
    if (!vulnerability) return;

    this.id = vulnerability.id;
    this.name = vulnerability.name;
    this.discovery_date = vulnerability.discovery_date;
    this.is_fixed = vulnerability.is_fixed;
    this.long_text_description = vulnerability.long_text_description;
    this.vuln_hardware = vulnerability.vuln_hardware;
    this.vuln_types = vulnerability.vuln_types;

    return this;
  }

  public fromTable(table: VulnerabilityTable): this {
    this.id = table.id;
    this.name = table.name;
    this.is_fixed = table.is_fixed;
    this.long_text_description = table.description;

    this.discovery_date = parse(table.discovery_date, DateTimeFormat, new Date());

    this.vuln_hardware = table.vuln_hardware.map((vuln_hardware) => ({
      hardware: {
        id: parseInt(vuln_hardware.value),
        name: vuln_hardware.text,
      },
    }));

    this.vuln_types = table.vuln_types.map((vuln_type) => ({
      vuln_types_list: {
        id: parseInt(vuln_type.value),
        title: vuln_type.text,
      },
    }));

    return this;
  }

  public toTable(): VulnerabilityTable {
    const discovery_date = this.discovery_date ? format(this.discovery_date, DateTimeFormat) : '';

    return {
      id: this.id,
      name: this.name,
      description: this.long_text_description,
      discovery_date: discovery_date,
      is_fixed: !!this.is_fixed,
      vuln_hardware: this.vuln_hardware.map((vuln_hardware) => ({
        text: vuln_hardware.hardware.name,
        value: vuln_hardware.hardware.id.toString(),
      })),
      vuln_types: this.vuln_types.map((vuln_type) => ({
        text: vuln_type.vuln_types_list.title,
        value: vuln_type.vuln_types_list.id.toString(),
      })),
    };
  }

  public toVulnerability(): Vulnerability {
    return {
      id: this.id,
      name: this.name,
      discovery_date: this.discovery_date,
      is_fixed: this.is_fixed,
      long_text_description: this.long_text_description,
      vuln_hardware: this.vuln_hardware,
      vuln_types: this.vuln_types,
    };
  }
}
